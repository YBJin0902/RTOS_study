# RTOS

以 Free RTOS open source 實作，搭配 STM32 與 HT32 系列開發版

</br>

# 簡介與基礎認知

### 前後台系統

前後台系統常建設在一般的程序上，簡單來說就是直接裸機操作 (直接套用while無限回圈內)。
須注意此系統並沒有嵌入式操作系統的改念

* 前台系統：中斷 (interrupt) 用於處理系統的異步事件 (callback)。

* 後台系統：程序是個死循環，在循環中不斷調用 API 函數完成所需的事件。

```
NOTE !! ：

前台系統為中斷級，後台為任務級
```

</br>

![Front desk system diagram](/images/Front_desk_system_diagram.png)

</br>


### RTOS 系統

即為即時性作業系統，並強調即時性，又分為軟即時與硬即時。將需要實現的功能劃分為多個任務，並具有可剝奪性。

代表作：FreeRTOS、UCOS、RT-Thread、DJYOS

* 軟即時：系統能讓絕大多數任務在確定時間內完成。

* 硬即時：系統必須使任務在確定的時間內完成。

* 可剝奪性：CPU執行多個任務中優先權最高的那個任務，即使CPU正在執行某個低階任務，當高階任務準備好時，高階任務就會優先搶奪執行權。

</br>

![Backend system diagram](/images/Backend_system_digram.png)

</br>

# Free RTOS

## 簡介

FreeRTOS 是一個可剪裁、可剝奪型的多任務核心，而且沒有任務數量限制。

官網：https://www.freertos.org/index.html


## 原始碼

下載：https://freertos.org/a00104.html

* 核心程式碼：(Source)
    * tasks.c：掌管所有 task 的檔案
    * queue.c：管理 task 間的通訊
    * list.c：提供系統與應用實作會用到的 list 結構

* 硬體相關檔案：以 ARM Cortext-M3 為例，可在 Source/portable/GCC/ARM_CM3 中找到
    * portmacro.h：定義了與硬體相關的變數，如資料型態定義，以及與硬體相關的函式呼叫名稱定義(以 portXXXXX 命名)等，統一各平臺的函式呼叫
    * port.c：定義了包含與硬體相關的程式碼實作
    * FreeRTOSConfig.h：包含 clock speed, heap size, mutexes 等等都在此定義(需自行建立)

</br>

### 架構
FreeRTOS 的程式碼可以分為三個主要區塊：任務、通訊和硬體界面。

* 任務(Tasks)：FreeRTOS 的核心程式碼約有一半是用來處理多數作業系統首要關注的問題：任務，任務是擁有優先權的用戶所定義的 C 函數。task.c 和 task.h 負責所有關於建立、排程和維護任務的繁重工作。

* 通訊(Communication)：FreeRTOS 核心程式碼大約有 40% 是用來處理通訊的。queue.c 和 queue.h 負責處理 FreeRTOS 的通訊，任務和中斷(interrupt)使用佇列(佇列，queue)互相發送數據，並且使用 semaphore 和 mutex 來派發 critical section 的使用信號。(~~資料結構很重要~~)

* 硬體介面：同一份程式碼在不同硬體平台上的 FreeRTOS 都可以運行。大約有 6% 的 FreeRTOS 核心代碼，在與硬體無關的 FreeRTOS 核心和與硬體相關的程式碼間扮演著墊片(shim)的角色。

</br>
</br>

在開始學習 RTOS 作業系統前，需要先了其解如何運作，如下圖所示為基本運作圖，展示了各 Task 如何交互與之間的關係

![FreeRTOS-TaskWork](/images/FreeRTOS-TaskWork.png)

1. 方格為狀態：
  * 運行：正在由 CPU 執行的狀態
  * 就緒：準備要執行的下一個狀態
  * 阻塞：在等待某個事件的狀態
  * 掛起：透過程式 API 要求退出之狀態

2. 方格之間的箭頭為需要透過地關係 (API)
  * Rusume：恢復狀態
  * Suspend：掛起狀態
  * Event (事件)：等待的事件
  * 阻塞函數：需要被等待的事件

</br>

經由第 2. 點可以發現，Rusume 與 Suspend 為相互的；Event 與 阻塞函數也為相互的。

</br>

接下來由流程的方式說明 RTOS 架構如何運作：

當一個任務被創建時 (視為黑點)，會處於就緒狀態。

任務被創建之後，使用者可以選擇要進行的動作，有兩種：運行、掛起；首先運行，就是直接運行該運務之內容；最後，掛起就是先將任務放置在一旁不進行運行，直到使用者需要時再透過 API 呼叫回復運行狀態。

其中較為特別的是阻塞，透過 API 的呼叫使任務被阻塞使得其他任務可以執行，這有關乎 RTOS 運作之關係， RTOS 之重點就在這，透過多個任務不斷互相阻塞與運行狀態達成類多執行序的效果。

</br>

---

</br>

以上說明可能較為難懂，以下由比喻的方式說明：

前情提要：
* 假設你的大腦是一個 MCU ，首先，你創建了三個任務分別是：動左腳、動右腳與躲避石頭。
* 當前情境為，你需要動左右腳進行走路，並且可能隨時會有人朝你丟石頭，所以你需要躲避。

</br>

各任務內容：
* 動左腳：抬起左腳 >> 放下左腳 >> 阻塞
* 動右腳：抬起右腳 >> 放下右腳 >> 阻塞
* 躲避石頭：躲避 >> 掛起
* 優先級：躲避石頭 > 動左腳 > 動右腳

</br>

開始執行：
* 創建各任務，其中躲避石頭創建完成後先掛起，因為躲避的動作不用時時刻刻進行；初始化完成，首先執行優先權級最大之任務，動左腳，當抬起左腳執行完成後，執行下一步驟放下左腳，此時進入阻塞狀態，系統開始尋找次優先權級之任務，動右腳，執行內部動作，執行完成後，再次尋找下一優先級，在這樣不斷得循環之中形成走路之動作。
  
* 突然有人朝你丟了石頭，你的大腦接收到了需要將躲避石頭恢復執行之動作，於是 Resume 了躲避石頭的任務，並將其執行，在執行完躲避的程序後，再將該任務掛起，因為並不需要一直處於躲避的狀態，直到下次需要應對時在恢復執行就好。

</br>

以上為基本的 RTOS 執行，實際上在撰寫與設計的過程中需要注意很多地方，例如：與中斷的交互、阻塞的等待事件、掛起與恢復執行的時間點...等等。

</br>

---

</br>

## 資料型態與命名規則

